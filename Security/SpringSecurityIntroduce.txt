CSRF (Cross Site Request Forgery):
    什么是 CSRF:
        当登录一个正常的网站 A，但是没有登出，会话信息仍保存在 Cookie 中，
        然后用户其他网站 B ，B 通过 JS 直接通过 <form method="POST"> 往 A 网站发请求时，浏览器会自动带上 A 网站的 Cookie，
        A 网站的服务器根据 Cookie 中的信息，当做是用户的正常请求，然而请求数据却是 B 网站伪造的
        使用 JS 脚本进行的跨站攻击叫做 XSS(Cross Site Script)

    解决方案：
        1. Synchronized Token Pattern:
            原理：
                HTTP 请求时不仅要携带 Cookie，还需要携带一个随机的 CSRF Token，
                服务器收到请求中 Token 后，跟自己保存的 Token 做对比，如果不匹配，那么拒绝该请求
            要点：
                CSRF Token 由服务器生成；
                不要在 GET 请求中携带 CSRF Token，会导致 Token 泄露
        2. 设置 Cookie 中的 SameSite 属性
            Set-Cookie: JSESSIONID=randomid; Domain=bank.example.com; Secure; HttpOnly; SameSite=Lax

            SameSite 的值：
                Strict: 只有同源网站发送的请求才会带上当前 Cookie
                Lax: 同源网站发送的请求，或者不同源网站发送的 幂等 的 HTTP 请求时，会带上当前 Cookie,

            幂等的 HTTP 请求有 GET, HEAD, OPTIONS, TRACE

    CSRF 防护类别：
        1. JSON 请求的防护
        2. Stateless (RESTful) 应用的防护
        3. Login
        4. Logout
        5. Multipart
            1. 将 CSRF Token 放到 Body 中； 会产生临时文件，但是无关紧要
            2. 将 CSRF Token 放到 URL 中； 会导致 Token 泄露

Security HTTP Response Headers:
    Spring Security 默认 HTTP Response Headers:
        Cache-Control: no-cache, no-store, max-age=0, must-revalidate
        Pragma: no-cache
        Expires: 0
        X-Content-Type-Options: nosniff
        Strict-Transport-Security: max-age=31536000 ; includeSubDomains
        X-Frame-Options: DENY
        X-XSS-Protection: 1; mode=block



Spring Security's terminology introduce:
    Authenticate: 动词：认证
    Authentication: 名词：认证方式
    Principal: 名词：主角，当前认证方式的主角，即用户
    Credential: 名词：凭证，即密码等能证明身份的东西

    Authorize: 动词：授权
    Authority: 名词：权限
    Authorization: 名词：授权书，即已被授权的证明


Authenticate:
    Chief Interface:
        AuthenticationToken: 封装后的认证请求
        AuthenticationManager: 对一个不完整的 AuthenticationToken 进行认证
        AuthenticateProvider: 表示一个 ProviderManager 里面认证链的节点
        Authentication: 认证方式接口，用于表示一种认证方式
        SecurityContext: 当前安全上下文，包含认证信息等

    Major Class:
        ProviderManager:
            SpringSecurity 默认提供的一个 AuthenticationManager 的实现类,
            该实现类提供一种链式的认证方式，可以使用 parent 构建 ProviderManager 层级关系
        AuthenticationManagerBuilder: 用于构建自定义的 AuthenticationManager
        SecurityContextHolder: 用于读取 SecurityContext

    Authenticate Procedure:
        1. 用户发起 authenticate request
        2. 将 authenticate request 封装成 AuthenticationToken 接口的一个实例
        3. 将 AuthenticationToken 实例传递给 AuthenticationManager 进行认证，
        4. 假如配置的 AuthenticationManager 实现类是 ProviderManager
        5. ProviderManager 调用内部的 AuthenticationProvider 链来完成认证
        6. AuthenticationProvider 调用 UserDetailsService 来获取系统中的用户信息
        7. UserDetailsService 返回一个 UserDetails 表示系统中的用户信息
        8. AuthenticationProvider 判断 AuthenticationToken 和 UserDetails 信息是否一致
            一致，认证成功： 返回一个 Authentication 实例
            不一致，认证失败： 抛出 AuthenticationException 异常
            null: 调用链中的下一个节点进行认证
        9. 认证成功后生成一个 SecurityContext 实例放到 ThreadLocal 中




Authorize:
    Principal Interface:
        ConfigAttributes: 代表一个被装饰过的受控资源
        AccessDecisionManager: 对一个完整的 Authentication 进行鉴权
        AccessDecisionVoter: 对某一个 Authority 进行投票，有三种票： 赞同票，反对票，弃权票
        GrantedAuthority: 表示已经被授予的权限

    Primary Class:
        AffirmativeBased: spring security 提供的一个 AccessDecisionManager, 一票通过机制
        ConsensusBased: 多数通过
        UnanimousBased: 全票通过


    Authorize Procedure:
        将当前的 Authentication



Web Security:
    Theory or Mechanism:
        在正常的 Servlet 容器中添加一个叫作 FilterChainProxy 的过滤器，
        该过滤器内部根据 URL 模式的不同，存在多个过滤器链，每一个过滤器针对一个 URL 模式，
        内部过滤器链由 DelegatingFilterProxy 组成


